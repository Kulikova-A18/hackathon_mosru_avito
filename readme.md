
### ЛЦТ 2025 — Сервис с backend driven подходом к построению интерфейсов пользователя

1.  **Цель:** Создать фреймворк BDUI следующего поколения (BDUI X).
2.  **Ключевая проблема:** Ускорить доставку изменений в UI, минуя долгий процесс мобильных релизов.
3.  **Обязательный минимум:**
    *   Бэкенд-сервис для хранения UI-конфигов (JSON).
    *   Админка для визуального конструктора UI.
    *   Клиентское приложение (1 платформа), отображающее конфиги.
    *   Hot Reload UI без обновления приложения.
    *   Встроенная аналитика по использованию элементов.
    *   Реализация конкретного макета из Figma.

---

**Концепция BDUI X:** No-Code платформа с AI-ассистентом, ориентированная на **скорость разработки**, **безопасность** и **data-driven итерации**.

**Стек технологий (рекомендованный):**
*   **Backend:** Kotlin (Spring Boot) - для лучшей совместимости с KMM из Beduin v2 в будущем.
*   **База данных:** PostgreSQL (для хранения конфигов, шаблонов, данных A/B тестов) + Redis (для кэширования конфигов и аналитики в реальном времени).
*   **Админка (Frontend):** React + TypeScript + MUI (Material-UI).
*   **Клиент (для демо):** Android (Kotlin, Jetpack Compose) - как наиболее близкий к Kotlin Multiplatform.
*   **Аналитика:** Кастомное решение + интеграция с Amplitude (по желанию).

---

### Архитектура решения

#### 1. Backend Service (`aether-backend`)

**Модули:**
*   `config-manager`: Отвечает за CRUD операций с UI-конфигурациями (экранами, компонентами, шаблонами). Хранит данные в PostgreSQL в виде JSONB.
*   `admin-api`: GraphQL или REST API для админ-панели. Предоставляет список компонентов, позволяет сохранять/извлекать макеты.
*   `client-api`: Оптимизированный REST API для клиентских приложений. Отдает готовый к отображению JSON. Кэширует ответы в Redis.
*   `analytics-collector`: Принимает события от клиентов (просмотры, клики) и пишет их в Redis/базу.
*   `ab-test-manager`: Управляет правилами A/B-тестов (если реализуем).

**Ключевые особенности:**
*   **Контракты на Kotlin DSL:** Как в Beduin v2, мы описываем компоненты на Kotlin DSL, который затем сериализуется в JSON для клиента. Это дает типобезопасность и возможность тестирования на бэкенде.
*   **Версионирование схем:** Каждое изменение конфига сохраняется с версией, что позволяет откатиться при проблемах.
*   **WebSocket/SSE:** Для реализации "горячего" обновления UI в админке и на клиенте.

#### 2. Административная Панель (`aether-admin`)

**Функционал:**
*   **Canvas (Холст):** Центральная область, где собирается интерфейс перетаскиванием (Drag&Drop) компонентов из палитры.
*   **Палитра Компонентов:** Список всех доступных компонентов (Button, Text, Image, List, Banner и т.д.), соответствующих дизайн-системе Авито (берем из Figma).
*   **Property Inspector (Инспектор свойств):** При выборе элемента на холсте появляется панель для редактирования его свойств (текст, цвет, размер, действия и т.д.).
*   **Режим предпросмотра:** Кнопка "Preview" открывает новое окно/вкладку с клиентским приложением, которое в реальном времени подтягивает конфиг с бэкенда.
*   **Панель Аналитики:** Графики и таблицы, показывающие, какие экраны и элементы чаще всего просматриваются и нажимаются.

**Инновация (AI):** Кнопка "AI Suggest". Анализирует текущую компоновку и данные аналитики (например, "на этом экране низкий CTR кнопки 'Купить'") и предлагает альтернативные варианты расположения или стилей элементов.

#### 3. Клиентское приложение (`aether-android`)

**Архитектура:**
*   **MVVM:** ViewModel загружает конфиг с бэкенда через Repository.
*   **Движок рендеринга:** Функция `@Composable fun AetherScreen(config: UiConfig)`, которая рекурсивно обходит полученный JSON и для каждого типа компонента вызывает соответствующий Composable-компонент.
*   **Компоненты:** Набор Composable-функций (`AetherText`, `AetherButton`, `AetherImage`), которые полностью соответствуют компонентам из админки и дизайн-системы.
*   **Навигация:** Навигация также задается через бэкенд (например, действие кнопки `{"action": "navigate", "screen_id": "product_detail"}`).

**Ключевые особенности:**
*   **Кэширование:** Приложение кэширует последнюю успешную конфигурацию для работы оффлайн.
*   **Подписка на обновления:** Используется WebSocket или Server-Sent Events (SSE) для получения команд от админки на мгновенное обновление интерфейса в режиме предпросмотра.
*   **Отправка аналитики:** Каждый клик и появление элемента на экране отправляется на бэкенд-сборщик аналитики.
